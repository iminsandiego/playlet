import "pkg:/components/Services/Innertube/InnertubeService.bs"
import "pkg:/components/Services/Invidious/InvidiousService.bs"
import "pkg:/source/utils/ArrayUtils.bs"

@job("VideoContentJob")
function ExecuteJob() as void
    input = JobGetInput()

    contentNode = input.content
    invidiousNode = input.invidious
    innertubeNode = input.innertube
    preferencesNode = input.preferences
    loungeServiceNode = input.loungeService
    playletServerPort = input.playletServerPort

    if JobIsCancelled()
        JobCancel()
        return
    end if

    DeleteFile("cachefs:/last_generated_dash.xml")
    DeleteFile("cachefs:/last_generated_hls.m3u8")

    if StringUtils.IsNullOrEmpty(contentNode.videoId)
        JobError("Can't load video information: videoId is missing")
        return
    end if

    service = new Invidious.InvidiousService(invidiousNode)
    backend = preferencesNode["backend.selected"]

    metadata = contentNode.metadata
    if not IsAssociativeArray(metadata)
        cancellation = JobGetCancellation()
        if backend = "playlet"
            visitorData = innertubeNode.visitorData
            if StringUtils.IsNullOrEmpty(visitorData)
                messagePort = CreateObject("roMessagePort")
                MessagePortUtils.ObserveFieldScopedExSafe(innertubeNode, "visitorData", messagePort)
                innertubeNode.requestVisitorData = true
                message = wait(20000, messagePort)
                innertubeNode.unobserveFieldScoped("visitorData")
                if message = invalid
                    innertubeNode.forceRequestVisitorData = true
                    JobError("Failed to get visitor data. Please try again later.")
                    return
                end if
                visitorData = message.getData()
            end if

            accessToken = invalid
            onBehalfOfUser = invalid
            authToken = invidiousNode.authToken
            if authToken <> invalid and authToken.profileNode <> invalid and authToken.profileNode.type = "youtube" and not StringUtils.IsNullOrEmpty(authToken.token)
                accessToken = authToken.token
                onBehalfOfUser = authToken.activeIdentifyToken
            end if

            metadata = InnertubeService.GetVideoMetadata(contentNode.videoId, {
                "cancellation": cancellation
                "credentialTransferToken": loungeServiceNode.credentialTransferToken
                "visitorData": visitorData
                "accessToken": accessToken
                "onBehalfOfUser": onBehalfOfUser
                "signatureTimestamp": true
            })
        else
            metadata = service.GetVideoMetadata(contentNode.videoId, { cancellation: m.top.cancellation })
        end if
    end if

    if JobIsCancelled()
        JobCancel()
        return
    end if

    if metadata = invalid
        JobError("Failed to get video metadata")
        return
    end if

    title = metadata.title
    if not StringUtils.IsNullOrEmpty(title)
        contentNode.title = title
    end if

    author = metadata.author
    if not StringUtils.IsNullOrEmpty(author)
        contentNode.secondaryTitle = metadata.author
    end if
    contentNode.live = metadata.liveNow

    if metadata.error <> invalid
        ' Adding metadata allows us to play next recommended video after displaying the error
        contentNode.addFields({ metadata: metadata })
        JobError(metadata.error)
        return
    end if

    streamUrls = CreateStreamUrls(metadata, service, preferencesNode, backend, playletServerPort)
    if streamUrls.Count() = 0
        contentNode.addFields({ metadata: metadata })
        error = "No playable streams found for this video."
        lastPlayerResponse = ValidString(ReadAsciiFile("cachefs:/last_player_response.json"))
        LogTelemetryEvent({
            level: "error"
            message: error
            fingerprint: error
            attachments: [{
                filename: "last_player_response.json"
                content_type: "application/json"
                data: lastPlayerResponse
            }]
        })
        JobError(error)
        return
    end if

    ' Clear any prior DRM params on reused nodes (non-DRM videos should not inherit drmParams)
    if contentNode.DoesExist("drmParams")
        contentNode.drmParams = invalid
    end if

    isDrm = not StringUtils.IsNullOrEmpty(metadata.drmParams)
    if isDrm
        licenseServerURL = UrlUtils.BuildUrl(`http://127.0.0.1:${playletServerPort}/api/innertube/get_drm_license`, invalid, {
            videoId: metadata.videoId
            drmParams: metadata.drmParams
            drmSessionId: metadata.drmSessionId
            cpn: metadata.cpn
        })
        contentNode.drmParams = {
            keySystem: "Widevine"
            licenseServerURL: licenseServerURL
        }
    end if

    ' Forwarding query params to HLS playlists is not needed. In fact, it can cause issues
    ' because the playlist is limited to 4MB, and on large playlists the query params
    ' significantly increase the size of the playlist, making it cropped.
    ' https://github.com/iBicha/playlet/issues/500
    contentNode.ForwardQueryStringParams = false
    contentNode.addFields({
        metadata: metadata
        ' StreamUrls is taken
        playletStreamUrls: streamUrls
        playletStreamUrlIndex: 0
    })

    firstUrl = streamUrls[0]
    LogDebug("Setting first url:", firstUrl)
    if StringUtils.IsNullOrEmpty(firstUrl)
        LogError("First stream URL is empty!")
    end if
    contentNode.url = firstUrl

    SetCaptions(metadata, service, contentNode)

    if metadata.liveNow = true
        contentNode.Live = true
    end if
end function

' Temporary: force playback speed for debugging.
' Set to invalid to disable forcing.
function GetForcedPlaybackSpeed() as dynamic
    return "1.5"
end function

function CreateStreamUrls(metadata as object, service as Invidious.InvidiousService, preferences as object, backend as string, playletServerPort as integer) as object
    instance = service.GetInstance()
    proxyVideos = preferences["invidious.proxy_videos"]
    preferredQuality = preferences["playback.preferred_quality"]
    dashPreferredQuality = preferredQuality

    ' Check device codec support for DASH
    ' Important: Roku only supports VP9 in WebM/MKV/HLS containers, NOT in DASH!
    ' Only AV1 and HEVC are supported via DASH for 4K content.
    ' See: https://developer.roku.com/en-ca/docs/specs/media/streaming-specifications.md
    codecSupport = DeviceSupports4kDash(false) ' Don't force - we need accurate detection

    ' Check what 4K codecs are actually available in this video's streams
    available4kCodecs = GetAvailable4kCodecs(metadata)

    ' For 4K via DASH, we need a MATCHING codec:
    ' - Device supports AV1 AND video has AV1 4K streams, OR
    ' - Device supports HEVC AND video has HEVC 4K streams
    ' VP9 doesn't work in DASH on Roku, only in HLS/WebM containers
    canUseAv1Dash = codecSupport.av1Dash and available4kCodecs.hasAv1
    canUseHevcDash = codecSupport.hevcDash and available4kCodecs.hasHevc
    supportsAv1OrHevcDash = canUseAv1Dash or canUseHevcDash

    LogAvailableVideoSources(metadata)
    LogDeviceVideoCapabilities(metadata)
    LogInfo(`4K DASH codec support: AV1=${codecSupport.av1Dash}, HEVC=${codecSupport.hevcDash}, VP9/DASH=${codecSupport.vp9Dash} (VP9 not usable in DASH on Roku)`)
    LogInfo(`Available 4K codecs in video: AV1=${available4kCodecs.hasAv1}, HEVC=${available4kCodecs.hasHevc}, VP9=${available4kCodecs.hasVp9}`)
    LogInfo(`Can use native 4K DASH: canUseAv1=${canUseAv1Dash}, canUseHevc=${canUseHevcDash}, result=${supportsAv1OrHevcDash}`)

    streamUrls = []
    hasDrmDash = SupportsDrmDashManifestUrl(metadata)
    forcedSpeed = GetForcedPlaybackSpeed()
    if forcedSpeed <> invalid
        playbackSpeed = NormalizePlaybackSpeed(forcedSpeed)
    else
        playbackSpeed = NormalizePlaybackSpeed(preferences["playback.speed"])
    end if
    if hasDrmDash
        ' DRM playback is handled via /api/dash?url=...; keep speed fixed at 1.0x
        playbackSpeed = "1.0"
    end if
    prefers4k = Prefers4kQuality(preferredQuality)
    muxerUrls = []
    if prefers4k
        muxerVcodec = "vp9"
        if codecSupport.vp9Hls <> true
            muxerVcodec = "h264"
        end if
        LogInfo(`Muxer HLS vcodec selection: prefers4k=${prefers4k}, vp9Hls=${codecSupport.vp9Hls}, h264Hls=${codecSupport.h264Hls}, selected=${muxerVcodec}`)
        muxerUrls = BuildMuxerUrls(preferences, metadata, preferredQuality, muxerVcodec)
    end if
    muxerUrl = muxerUrls.Count() > 0 ? muxerUrls[0] : invalid

    LogInfo(`Stream URL selection: preferredQuality=${preferredQuality}, prefers4k=${prefers4k}, supportsAv1OrHevcDash=${supportsAv1OrHevcDash}, muxerUrl=${muxerUrl}, hasDrmDash=${hasDrmDash}`)

    ' Strategy for 4K content:
    ' 1. If device supports AV1/HEVC via DASH → use native DASH (best quality, no server needed)
    ' 2. If muxer is available → use muxer (outputs VP9 via HLS which Roku supports)
    ' 3. Fall back to non-4K DASH/HLS
    ' Note: VP9 is only supported in HLS on Roku, not in DASH or direct WebM streaming
    ' See: https://developer.roku.com/en-ca/docs/specs/media/streaming-specifications.md

    if prefers4k
        if supportsAv1OrHevcDash
            ' Device supports 4K via DASH natively (AV1 or HEVC)
            LogInfo("Device supports AV1/HEVC via DASH - using native 4K DASH playback")
            ' dashPreferredQuality keeps 4K
        else if muxerUrls.Count() > 0
            ' Use muxer for 4K - prefer HLS packaging (VP9 is not usable via DASH on Roku)
            LogInfo(`Device doesn't support 4K DASH codecs but muxer is available - using muxer for 4K: ${FormatJson(muxerUrls)}`)
            for each url in muxerUrls
                streamUrls.push(url)
            end for
            ' Also strip 4K from DASH fallback since device can't play 4K via DASH
            dashPreferredQuality = BuildNon4kQuality(preferredQuality)
        else
            ' No 4K option available - fall back to non-4K
            dashPreferredQuality = BuildNon4kQuality(preferredQuality)
            LogWarnNoTelemetry("4K preferred but no 4K playback option available (no AV1/HEVC DASH support, no muxer). Falling back to:", dashPreferredQuality)
        end if
    end if

    if hasDrmDash
        dashUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/dash`, {
            url: metadata.dashUrl
        })
        streamUrls.push(dashUrl)
    else if SupportsHls(metadata)
        metadata.hlsUrl = AddInstanceToUrlIfNeeded(metadata.hlsUrl, instance)
        AddHlsUrls(streamUrls, metadata, dashPreferredQuality, backend, proxyVideos, playletServerPort)
    else if SupportsDash(metadata)
        AddDashUrls(streamUrls, metadata, dashPreferredQuality, backend, proxyVideos, playletServerPort, playbackSpeed)
    else if SupportsMuxedFormats(metadata)
        for each stream in metadata.formatStreams
            if StringUtils.IsNullOrEmpty(stream.url)
                continue for
            end if
            stream.url = AddInstanceToUrlIfNeeded(stream.url, instance)
            streamUrls.push(stream.url)
        end for
    end if

    LogInfo(`Final stream URLs (${streamUrls.Count()}): ${FormatJson(streamUrls)}`)

    ' Add muxer as fallback if it wasn't already added as primary
    if muxerUrls.Count() > 0 and not hasDrmDash and streamUrls.Count() > 0
        for each url in muxerUrls
            if ArrayUtils.IndexOfString(streamUrls, url) = -1
                streamUrls.push(url)
            end if
        end for
    end if

    return streamUrls
end function

function BuildNon4kQuality(preferredQuality as dynamic) as string
    if not IsString(preferredQuality)
        return "1080p,720p,480p,360p,240p,144p"
    end if

    values = preferredQuality.split(",")
    filtered = []
    for each value in values
        trimmed = value.Trim()
        if StringUtils.IsNullOrEmpty(trimmed)
            continue for
        end if
        normalized = LCase(trimmed)
        if normalized = "2160p" or normalized = "2160" or normalized = "4k"
            continue for
        end if
        filtered.push(trimmed)
    end for

    if filtered.Count() = 0
        return "1080p,720p,480p,360p,240p,144p"
    end if

    return filtered.Join(",")
end function

function GetAvailable4kCodecs(metadata as object) as object
    result = {
        hasAv1: false
        hasHevc: false
        hasVp9: false
    }

    adaptiveFormats = ValidArray(metadata.adaptiveFormats)

    for each fmt in adaptiveFormats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        ' Check if this is a 4K stream (2160p)
        qualityLabel = LCase(ValidString(fmt["qualityLabel"]))
        resolution = ValidString(fmt["resolution"])
        is4k = qualityLabel.InStr("2160") <> -1 or resolution.InStr("2160") <> -1 or resolution.InStr("3840") <> -1

        if not is4k
            continue for
        end if

        ' Parse the codec from mime type
        parsed = ParseMimeType(mimeType)
        codec = LCase(parsed.codec)

        ' Check codec type
        if codec.InStr("av01") <> -1 or codec.InStr("av1") <> -1
            result.hasAv1 = true
        else if codec.InStr("hvc1") <> -1 or codec.InStr("hev1") <> -1 or codec.InStr("hevc") <> -1 or codec.InStr("h265") <> -1
            result.hasHevc = true
        else if codec.InStr("vp9") <> -1 or codec.InStr("vp09") <> -1
            result.hasVp9 = true
        end if
    end for

    return result
end function

function LogAvailableVideoSources(metadata as object) as void
    adaptiveFormats = ValidArray(metadata.adaptiveFormats)
    formatStreams = ValidArray(metadata.formatStreams)

    lines = []
    AddVideoSourceLines(lines, adaptiveFormats, "adaptive")
    AddVideoSourceLines(lines, formatStreams, "muxed")

    if lines.Count() = 0
        LogDebug("Available video sources: none")
        return
    end if

    LogDebug("Available video sources:\n" + lines.Join(`\n`))
end function

function AddVideoSourceLines(lines as object, formats as object, sourceLabel as string) as void
    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        lines.Push(FormatVideoSourceLine(fmt, sourceLabel))
    end for
end function

function FormatVideoSourceLine(fmt as object, sourceLabel as string) as string
    itag = ValidString(fmt["itag"])
    mimeType = ValidString(fmt["type"])
    parsed = ParseMimeType(mimeType)
    container = parsed.container
    codec = parsed.codec

    resolution = ValidString(fmt["resolution"])
    if StringUtils.IsNullOrEmpty(resolution)
        resolution = ValidString(fmt["qualityLabel"])
    end if
    if StringUtils.IsNullOrEmpty(resolution)
        resolution = ValidString(fmt["size"])
    end if

    fps = ValidString(fmt["fps"])
    bitrate = FormatBitrate(fmt["bitrate"])

    parts = [sourceLabel]
    if not StringUtils.IsNullOrEmpty(itag)
        parts.Push(`itag=${itag}`)
    end if
    if not StringUtils.IsNullOrEmpty(container)
        parts.Push(`container=${container}`)
    end if
    if not StringUtils.IsNullOrEmpty(codec)
        parts.Push(`codec=${codec}`)
    end if
    if not StringUtils.IsNullOrEmpty(resolution)
        parts.Push(`res=${resolution}`)
    end if
    if not StringUtils.IsNullOrEmpty(fps)
        parts.Push(`fps=${fps}`)
    end if
    if not StringUtils.IsNullOrEmpty(bitrate)
        parts.Push(`bitrate=${bitrate}`)
    end if
    if fmt["drmFamilies"] <> invalid
        parts.Push(`drm=${ToString(fmt["drmFamilies"])}`)
    end if

    return parts.Join(" ")
end function

function LogDeviceVideoCapabilities(metadata as object) as void
    deviceInfo = CreateObject("roDeviceInfo")
    if deviceInfo = invalid
        LogDebug("Device video decode capabilities: roDeviceInfo unavailable")
        return
    end if

    combos = {}
    AppendVideoDecodeCombos(combos, ValidArray(metadata.adaptiveFormats), "dash")
    AppendVideoDecodeCombos(combos, ValidArray(metadata.formatStreams), "")

    if combos.Count() = 0
        LogDebug("Device video decode capabilities: no codecs to check")
        return
    end if

    lines = []
    for each key in combos
        combo = combos[key]
        result = deviceInfo.CanDecodeVideo({ codec: combo.codec, container: combo.container })
        lines.Push(`${combo.container}/${combo.codec}=${FormatDecodeInfo(result)}`)
    end for

    LogDebug("Device video decode capabilities:\n" + lines.Join(`\n`))
end function

function AppendVideoDecodeCombos(combos as object, formats as object, containerOverride as string) as void
    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        parsed = ParseMimeType(mimeType)
        codec = NormalizeVideoCodec(parsed.codec)
        if StringUtils.IsNullOrEmpty(codec)
            continue for
        end if

        container = containerOverride
        if StringUtils.IsNullOrEmpty(container)
            container = parsed.container
        end if
        if StringUtils.IsNullOrEmpty(container)
            continue for
        end if

        key = `${container}|${codec}`
        if not combos.DoesExist(key)
            combos[key] = { container: container, codec: codec }
        end if
    end for
end function

function ParseMimeType(mimeType as string) as object
    result = { container: "", codec: "" }
    if StringUtils.IsNullOrEmpty(mimeType)
        return result
    end if

    parts = mimeType.Split(";")
    typePart = parts[0].Trim()
    slashIndex = typePart.InStr("/")
    if slashIndex <> -1
        result.container = typePart.Mid(slashIndex + 1)
    end if

    for each part in parts
        trimmed = part.Trim()
        if trimmed.StartsWith("codecs=")
            codecList = trimmed.Mid(7)
            codecList = codecList.Replace(chr(34), "")
            codecList = codecList.Replace("'", "")
            result.codec = codecList
            exit for
        end if
    end for

    return result
end function

function NormalizeVideoCodec(codecList as string) as string
    if StringUtils.IsNullOrEmpty(codecList)
        return ""
    end if

    codec = codecList.Split(",")[0].Trim()
    lower = LCase(codec)
    if lower.StartsWith("av01")
        return "av1"
    else if lower.StartsWith("avc1") or lower.StartsWith("avc3")
        return "h264"
    else if lower.StartsWith("hev1") or lower.StartsWith("hvc1")
        return "h265"
    else if lower.StartsWith("vp9")
        return "vp9"
    else if lower.StartsWith("vp8")
        return "vp8"
    end if

    return ""
end function

function FormatBitrate(value as dynamic) as string
    bitrate = ValidInt(value)
    if bitrate <= 0
        return ""
    end if
    kbps = bitrate \ 1000
    if kbps <= 0
        return `${bitrate} bps`
    end if
    return `${kbps} kbps`
end function

function FormatDecodeInfo(value as dynamic) as string
    if IsBool(value)
        return value.ToStr()
    end if
    if IsAssociativeArray(value) and value.DoesExist("result")
        return ToString(value["result"])
    end if
    return ToString(value)
end function

function BuildMuxerUrl(preferences as object, metadata as object, preferredQuality as dynamic, container = "webm" as string, vcodec = "" as string) as dynamic
    muxerBaseUrl = ValidString(preferences["playback.muxer_base_url"])
    muxerBaseUrl = muxerBaseUrl.Trim()
    if StringUtils.IsNullOrEmpty(muxerBaseUrl)
        LogDebug("BuildMuxerUrl: muxer_base_url is not configured")
        return invalid
    end if

    if not Prefers4kQuality(preferredQuality)
        LogDebug(`BuildMuxerUrl: preferredQuality=${preferredQuality} does not include 4K`)
        return invalid
    end if

    muxerBaseUrl = NormalizeMuxerBaseUrl(muxerBaseUrl)
    if StringUtils.IsNullOrEmpty(muxerBaseUrl)
        return invalid
    end if

    ' Try HLS endpoint first (VP9 works in HLS on Roku), fall back to /mux with WebM.
    ' Note: For HLS playback we prefer an endpoint ending in .m3u8 so Roku reliably detects the format.
    if muxerBaseUrl.Len() >= 4 and muxerBaseUrl.Right(4) = "/hls"
        muxerUrl = muxerBaseUrl
        useHls = true
    else if muxerBaseUrl.Len() >= 5 and muxerBaseUrl.Right(5) = "/dash"
        muxerUrl = muxerBaseUrl.Left(muxerBaseUrl.Len() - 5) + "/mux"
        useHls = false
    else if muxerBaseUrl.Len() >= 4 and muxerBaseUrl.Right(4) = "/mux"
        muxerUrl = muxerBaseUrl
        useHls = false
    else
        muxerUrl = StringUtils.PathJoin(muxerBaseUrl, "mux")
        useHls = false
    end if

    videoId = metadata.videoId
    if StringUtils.IsNullOrEmpty(videoId)
        return invalid
    end if

    container = LCase(container.Trim())
    if container <> "webm" and container <> "mkv" and container <> "hls"
        container = "webm"
    end if

    vcodec = LCase(ValidString(vcodec).Trim())

    if container = "hls"
        if muxerUrl.Len() >= 4 and muxerUrl.Right(4) = "/hls"
            muxerUrl = muxerUrl + ".m3u8"
        else if muxerUrl.Len() >= 4 and muxerUrl.Right(4) = "/mux"
            muxerUrl = muxerUrl + ".m3u8"
        end if
    end if

    params = {
        v: videoId
        quality: "2160p"
        container: container
    }

    if container = "hls" and not StringUtils.IsNullOrEmpty(vcodec)
        params.vcodec = vcodec
    end if

    LogInfo(`BuildMuxerUrl: using endpoint=${muxerUrl}, useHls=${useHls}, container=${container}`)
    return UrlUtils.AppendQueryParams(muxerUrl, params)
end function

function BuildMuxerUrls(preferences as object, metadata as object, preferredQuality as dynamic, muxerVcodec = "" as string) as object
    urls = []

    hlsUrl = BuildMuxerUrl(preferences, metadata, preferredQuality, "hls", muxerVcodec)
    if hlsUrl <> invalid
        urls.push(hlsUrl)
    end if

    webmUrl = BuildMuxerUrl(preferences, metadata, preferredQuality, "webm")
    if webmUrl <> invalid and webmUrl <> hlsUrl
        urls.push(webmUrl)
    end if

    return urls
end function

function NormalizeMuxerBaseUrl(url as string) as string
    normalized = url.Trim()
    if StringUtils.IsNullOrEmpty(normalized)
        return ""
    end if

    lower = LCase(normalized)
    if lower.StartsWith("http//")
        normalized = "http://" + normalized.Mid(6)
        lower = LCase(normalized)
    else if lower.StartsWith("https//")
        normalized = "https://" + normalized.Mid(7)
        lower = LCase(normalized)
    end if

    if not lower.StartsWith("http://") and not lower.StartsWith("https://")
        normalized = "http://" + normalized
    end if

    if normalized.EndsWith("/")
        normalized = normalized.Left(normalized.Len() - 1)
    end if

    return normalized
end function

function Prefers4kQuality(preferredQuality as dynamic) as boolean
    if not IsString(preferredQuality)
        return false
    end if

    values = preferredQuality.split(",")
    for each value in values
        candidate = LCase(value.Trim())
        if candidate = "2160p" or candidate = "2160" or candidate = "4k"
            return true
        end if
    end for

    return false
end function

function DeviceSupports4kDash(runDiagnostics = false as boolean) as object
    result = {
        av1Dash: false
        vp9Dash: false
        vp9Webm: false
        vp9Hls: false
        hevcDash: false
        h264Hls: false
    }

    deviceInfo = CreateObject("roDeviceInfo")
    if deviceInfo = invalid
        return result
    end if

    ' Run extended diagnostics if requested
    if runDiagnostics
        LogExtendedCodecDiagnostics()
    end if

    ' Check AV1 via DASH - this is the primary 4K codec for DASH on Roku
    result.av1Dash = CheckCanDecodeVideo(deviceInfo, "av1", "dash")

    ' Check VP9 via DASH - Note: Even if this returns true, Roku doesn't actually
    ' support VP9 in DASH containers per their streaming specs. VP9 only works
    ' in WebM/MKV containers or via HLS.
    ' See: https://developer.roku.com/en-ca/docs/specs/media/streaming-specifications.md
    result.vp9Dash = CheckCanDecodeVideo(deviceInfo, "vp9", "dash")

    ' Check VP9 via webm - this indicates VP9 hardware support
    ' The muxer uses WebM container for VP9 which works on Roku
    result.vp9Webm = CheckCanDecodeVideo(deviceInfo, "vp9", "webm")

    ' Check VP9 via HLS (some devices support VP9 only via HLS packaging)
    result.vp9Hls = CheckCanDecodeVideo(deviceInfo, "vp9", "hls")

    ' Check HEVC/H.265 via DASH
    result.hevcDash = CheckCanDecodeVideo(deviceInfo, "hevc", "dash")

    ' Check H.264 via HLS (fallback when VP9 isn't decodable)
    result.h264Hls = CheckCanDecodeVideo(deviceInfo, "h264", "hls")
    if not result.h264Hls
        result.h264Hls = CheckCanDecodeVideo(deviceInfo, "avc1", "hls")
    end if

    LogDebug("Device codec support:", `av1/dash=${result.av1Dash}, vp9/dash=${result.vp9Dash}, vp9/webm=${result.vp9Webm}, vp9/hls=${result.vp9Hls}, hevc/dash=${result.hevcDash}, h264/hls=${result.h264Hls}`)

    return result
end function

function CheckCanDecodeVideo(deviceInfo as object, codec as string, container as string) as boolean
    decodeInfo = deviceInfo.CanDecodeVideo({ "codec": codec, "container": container })

    ' Log the raw result for debugging
    LogDebug(`CanDecodeVideo(codec=${codec}, container=${container}) returned:`, ToString(decodeInfo))

    if IsBool(decodeInfo)
        return decodeInfo
    end if

    if IsAssociativeArray(decodeInfo)
        return ValidBool(decodeInfo.result)
    end if

    return false
end function

' Comprehensive codec diagnostics - call this to dump all relevant codec support info
function LogExtendedCodecDiagnostics() as void
    deviceInfo = CreateObject("roDeviceInfo")
    if deviceInfo = invalid
        LogWarn("Cannot get roDeviceInfo for codec diagnostics")
        return
    end if

    LogInfo("=== Extended Codec Diagnostics ===")

    ' Device info
    LogInfo(`Device Model: ${deviceInfo.GetModel()}`)
    LogInfo(`Model Display Name: ${deviceInfo.GetModelDisplayName()}`)

    ' Test various codec/container combinations
    codecs = ["vp9", "vp09", "av1", "av01", "hevc", "hvc1", "hev1", "h264", "avc1"]
    containers = ["dash", "webm", "mp4", "mkv", "hls"]

    for each codec in codecs
        for each container in containers
            result = deviceInfo.CanDecodeVideo({ "codec": codec, "container": container })
            LogInfo(`CanDecodeVideo(${codec}/${container}): ${ToString(result)}`)
        end for
    end for

    ' Also try with profile/level for VP9
    vp9Profiles = [
        { "codec": "vp9", "container": "webm" }
        { "codec": "vp9", "container": "webm", "profile": "0" }
        { "codec": "vp9", "container": "webm", "profile": "2" }
        { "codec": "vp9", "container": "dash", "profile": "0" }
        { "codec": "vp9", "container": "dash", "profile": "2" }
        { "codec": "vp9", "container": "mp4" }
    ]

    LogInfo("=== VP9 Profile Tests ===")
    for each opts in vp9Profiles
        result = deviceInfo.CanDecodeVideo(opts)
        LogInfo(`CanDecodeVideo(${FormatJson(opts)}): ${ToString(result)}`)
    end for

    LogInfo("=== End Codec Diagnostics ===")
end function

' Keep the old function name for backward compatibility in DashRouter
function DeviceSupportsAv1Dash() as boolean
    result = DeviceSupports4kDash()
    return result.av1Dash
end function

function SupportsHls(metadata as object) as boolean
    return not StringUtils.IsNullOrEmpty(metadata.hlsUrl)
end function

function SupportsDash(metadata as object) as boolean
    if not IsArray(metadata.adaptiveFormats) or metadata.adaptiveFormats.Count() = 0
        return false
    end if

    for each fmt in metadata.adaptiveFormats
        if not StringUtils.IsNullOrEmpty(fmt.url)
            return true
        end if
    end for

    return false
end function

function SupportsMuxedFormats(metadata as object) as boolean
    return IsArray(metadata.formatStreams) and metadata.formatStreams.Count() > 0
end function

function SupportsDrmDashManifestUrl(metadata as object) as boolean
    if StringUtils.IsNullOrEmpty(metadata.drmParams)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.dashUrl)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.drmSessionId)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.cpn)
        return false
    end if

    if not IsArray(metadata.licenseInfos) or metadata.licenseInfos.Count() = 0
        return false
    end if

    return true
end function

function AddHlsUrls(streamUrls as object, metadata as object, preferredQuality as string, backend as string, proxyVideos as string, playletServerPort as integer)
    hlsUrl = metadata.hlsUrl
    hlsUrlLocal = invalid
    hlsUrlFiltered = invalid
    hlsUrlFilteredLocal = invalid

    supportsProxying = backend <> "playlet"
    hasQuality = not StringUtils.IsNullOrEmpty(preferredQuality) and preferredQuality <> "auto"

    if supportsProxying
        hlsUrlLocal = UrlUtils.AppendQueryParams(hlsUrl, { local: "true" })
    end if

    ' Redirect to Playet's local web server, where we will be
    ' dynamically adding storyboards to the HLS manifest, and filter quality
    hlsUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/hls`, { url: hlsUrl, v: metadata.videoId })
    if supportsProxying
        hlsUrlLocal = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/hls`, { url: hlsUrlLocal, v: metadata.videoId })
    end if

    if hasQuality
        hlsUrlFiltered = UrlUtils.AppendQueryParams(hlsUrl, { quality: preferredQuality })
        if supportsProxying
            hlsUrlFilteredLocal = UrlUtils.AppendQueryParams(hlsUrlLocal, { quality: preferredQuality })
        end if
    end if

    AddUrls(streamUrls, hlsUrl, hlsUrlLocal, hlsUrlFiltered, hlsUrlFilteredLocal, proxyVideos)
end function

function AddDashUrls(streamUrls as object, metadata as object, preferredQuality as string, backend as string, proxyVideos as string, playletServerPort as integer, playbackSpeed as string) as void
    ' Redirect to Playet's local web server, where will will be
    ' dynamically generating the DASH manifest, and filter quality
    dashUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/dash`, {
        v: metadata.videoId
    })

    if playbackSpeed <> invalid and playbackSpeed <> "1.0"
        dashUrl = UrlUtils.AppendQueryParams(dashUrl, { speed: playbackSpeed })
    end if

    dashUrlLocal = invalid
    dashUrlFiltered = invalid
    dashUrlFilteredLocal = invalid

    supportsProxying = backend <> "playlet"
    hasQuality = not StringUtils.IsNullOrEmpty(preferredQuality) and preferredQuality <> "auto"

    if supportsProxying
        dashUrlLocal = UrlUtils.AppendQueryParams(dashUrl, { local: "true" })
    end if

    if hasQuality
        dashUrlFiltered = UrlUtils.AppendQueryParams(dashUrl, { quality: preferredQuality })
        if supportsProxying
            dashUrlFilteredLocal = UrlUtils.AppendQueryParams(dashUrlLocal, { quality: preferredQuality })
        end if
    end if

    AddUrls(streamUrls, dashUrl, dashUrlLocal, dashUrlFiltered, dashUrlFilteredLocal, proxyVideos)
end function

function AddUrls(streamUrls as object, url as string, urlLocal as dynamic, urlFiltered as dynamic, urlFilteredLocal as dynamic, proxyVideos as string)
    if proxyVideos = "if_needed"
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    else if proxyVideos = "never"
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
    else if proxyVideos = "always"
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    end if

    if streamUrls.Count() = 0
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    end if
end function

function NormalizePlaybackSpeed(value as dynamic) as string
    speedStr = ValidString(value)
    if StringUtils.IsNullOrEmpty(speedStr)
        return "1.0"
    end if

    ' Allow values like "1.25x"
    if speedStr.EndsWith("x")
        speedStr = speedStr.Left(speedStr.Len() - 1)
    end if

    ' Normalize numeric formatting (e.g. "2.00" -> 2.0) and then whitelist
    speed = Val(speedStr)
    if speed <= 0
        return "1.0"
    end if

    ' Keep this list in sync with the in-player selector (SpeedSelector)
    supported = [0.5, 0.75, 1.0, 1.25, 1.5, 2.0]
    supportedStr = ["0.5", "0.75", "1.0", "1.25", "1.5", "2.0"]

    for i = 0 to supported.Count() - 1
        if Abs(speed - supported[i]) < 0.001
            return supportedStr[i]
        end if
    end for

    return "1.0"
end function

function AddInstanceToUrlIfNeeded(url as dynamic, instance as string) as dynamic
    if IsString(url) and url.StartsWith("/")
        return instance + url
    end if
    return url
end function

function SetCaptions(metadata as object, service as object, contentNode as object) as void
    if metadata.captions.Count() = 0
        return
    end if

    isoLanguageList = StringUtils.ParseJsonSafe(ReadAsciiFile("libpkg:/config/ISO-639-1-to-ISO-639-2T.json5"))
    instance = service.GetInstance()

    subtitleTracks = []

    for each caption in metadata.captions
        code = caption.language_code
        if StringUtils.IsNullOrEmpty(code)
            continue for
        end if

        if code.InStr("-") <> -1
            code = code.Split("-")[0]
        end if

        if code.len() = 2
            if not isoLanguageList.DoesExist(code)
                continue for
            end if
            code = isoLanguageList[code]
        end if

        url = caption.url
        if not url.StartsWith("http")
            url = instance + url
        end if

        subtitleTracks.Push({
            Description: caption.label
            Language: code
            TrackName: url
        })
    end for

    contentNode.ClosedCaptions = True
    contentNode.SubtitleTracks = subtitleTracks
end function
