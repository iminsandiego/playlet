import "pkg:/components/Services/Innertube/InnertubeService.bs"
import "pkg:/components/Services/Invidious/InvidiousService.bs"

@job("VideoContentJob")
function ExecuteJob() as void
    input = JobGetInput()

    contentNode = input.content
    invidiousNode = input.invidious
    innertubeNode = input.innertube
    preferencesNode = input.preferences
    loungeServiceNode = input.loungeService
    playletServerPort = input.playletServerPort

    if JobIsCancelled()
        JobCancel()
        return
    end if

    DeleteFile("cachefs:/last_generated_dash.xml")
    DeleteFile("cachefs:/last_generated_hls.m3u8")

    if StringUtils.IsNullOrEmpty(contentNode.videoId)
        JobError("Can't load video information: videoId is missing")
        return
    end if

    service = new Invidious.InvidiousService(invidiousNode)
    backend = preferencesNode["backend.selected"]

    metadata = contentNode.metadata
    if not IsAssociativeArray(metadata)
        cancellation = JobGetCancellation()
        if backend = "playlet"
            visitorData = innertubeNode.visitorData
            if StringUtils.IsNullOrEmpty(visitorData)
                messagePort = CreateObject("roMessagePort")
                MessagePortUtils.ObserveFieldScopedExSafe(innertubeNode, "visitorData", messagePort)
                innertubeNode.requestVisitorData = true
                message = wait(20000, messagePort)
                innertubeNode.unobserveFieldScoped("visitorData")
                if message = invalid
                    innertubeNode.forceRequestVisitorData = true
                    JobError("Failed to get visitor data. Please try again later.")
                    return
                end if
                visitorData = message.getData()
            end if

            accessToken = invalid
            onBehalfOfUser = invalid
            authToken = invidiousNode.authToken
            if authToken <> invalid and authToken.profileNode <> invalid and authToken.profileNode.type = "youtube" and not StringUtils.IsNullOrEmpty(authToken.token)
                accessToken = authToken.token
                onBehalfOfUser = authToken.activeIdentifyToken
            end if

            metadata = InnertubeService.GetVideoMetadata(contentNode.videoId, {
                "cancellation": cancellation
                "credentialTransferToken": loungeServiceNode.credentialTransferToken
                "visitorData": visitorData
                "accessToken": accessToken
                "onBehalfOfUser": onBehalfOfUser
                "signatureTimestamp": true
            })
        else
            metadata = service.GetVideoMetadata(contentNode.videoId, { cancellation: m.top.cancellation })
        end if
    end if

    if JobIsCancelled()
        JobCancel()
        return
    end if

    if metadata = invalid
        JobError("Failed to get video metadata")
        return
    end if

    title = metadata.title
    if not StringUtils.IsNullOrEmpty(title)
        contentNode.title = title
    end if

    author = metadata.author
    if not StringUtils.IsNullOrEmpty(author)
        contentNode.secondaryTitle = metadata.author
    end if
    contentNode.live = metadata.liveNow

    if metadata.error <> invalid
        ' Adding metadata allows us to play next recommended video after displaying the error
        contentNode.addFields({ metadata: metadata })
        JobError(metadata.error)
        return
    end if

    streamUrls = CreateStreamUrls(metadata, service, preferencesNode, backend, playletServerPort)
    if streamUrls.Count() = 0
        contentNode.addFields({ metadata: metadata })
        error = "No playable streams found for this video."
        lastPlayerResponse = ValidString(ReadAsciiFile("cachefs:/last_player_response.json"))
        LogTelemetryEvent({
            level: "error"
            message: error
            fingerprint: error
            attachments: [{
                filename: "last_player_response.json"
                content_type: "application/json"
                data: lastPlayerResponse
            }]
        })
        JobError(error)
        return
    end if

    isDrm = not StringUtils.IsNullOrEmpty(metadata.drmParams)
    if isDrm
        licenseServerURL = UrlUtils.BuildUrl(`http://127.0.0.1:${playletServerPort}/api/innertube/get_drm_license`, invalid, {
            videoId: metadata.videoId
            drmParams: metadata.drmParams
            drmSessionId: metadata.drmSessionId
            cpn: metadata.cpn
        })
        contentNode.drmParams = {
            keySystem: "Widevine"
            licenseServerURL: licenseServerURL
        }
    end if

    ' Forwarding query params to HLS playlists is not needed. In fact, it can cause issues
    ' because the playlist is limited to 4MB, and on large playlists the query params
    ' significantly increase the size of the playlist, making it cropped.
    ' https://github.com/iBicha/playlet/issues/500
    contentNode.ForwardQueryStringParams = false
    contentNode.addFields({
        metadata: metadata
        ' StreamUrls is taken
        playletStreamUrls: streamUrls
        playletStreamUrlIndex: 0
    })

    firstUrl = streamUrls[0]
    LogDebug("Setting first url:", firstUrl)
    if StringUtils.IsNullOrEmpty(firstUrl)
        LogError("First stream URL is empty!")
    end if
    contentNode.url = firstUrl

    SetCaptions(metadata, service, contentNode)

    if metadata.liveNow = true
        contentNode.Live = true
    end if
end function

function CreateStreamUrls(metadata as object, service as Invidious.InvidiousService, preferences as object, backend as string, playletServerPort as integer) as object
    instance = service.GetInstance()
    proxyVideos = preferences["invidious.proxy_videos"]
    preferredQuality = preferences["playback.preferred_quality"]
    dashPreferredQuality = preferredQuality

    if Prefers4kQuality(preferredQuality) and not DeviceSupportsAv1Dash()
        dashPreferredQuality = BuildNon4kQuality(preferredQuality)
        LogWarnNoTelemetry("4K preferred but device does not support AV1; falling back to non-4K DASH qualities:", dashPreferredQuality)
    end if

    LogAvailableVideoSources(metadata)
    LogDeviceVideoCapabilities(metadata)

    streamUrls = []

    hasDrmDash = SupportsDrmDashManifestUrl(metadata)
    muxerUrl = BuildMuxerUrl(preferences, metadata, preferredQuality)
    if muxerUrl <> invalid and not hasDrmDash
        streamUrls.push(muxerUrl)
    end if

    if hasDrmDash
        dashUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/dash`, {
            url: metadata.dashUrl
        })
        streamUrls.push(dashUrl)
    else if SupportsHls(metadata)
        metadata.hlsUrl = AddInstanceToUrlIfNeeded(metadata.hlsUrl, instance)
        AddHlsUrls(streamUrls, metadata, dashPreferredQuality, backend, proxyVideos, playletServerPort)
    else if SupportsDash(metadata)
        AddDashUrls(streamUrls, metadata, dashPreferredQuality, backend, proxyVideos, playletServerPort)
    else if SupportsMuxedFormats(metadata)
        for each stream in metadata.formatStreams
            if StringUtils.IsNullOrEmpty(stream.url)
                continue for
            end if
            stream.url = AddInstanceToUrlIfNeeded(stream.url, instance)
            streamUrls.push(stream.url)
        end for
    end if

    return streamUrls
end function

function BuildNon4kQuality(preferredQuality as dynamic) as string
    if not IsString(preferredQuality)
        return "1080p,720p,480p,360p,240p,144p"
    end if

    values = preferredQuality.split(",")
    filtered = []
    for each value in values
        trimmed = value.Trim()
        if StringUtils.IsNullOrEmpty(trimmed)
            continue for
        end if
        normalized = LCase(trimmed)
        if normalized = "2160p" or normalized = "2160" or normalized = "4k"
            continue for
        end if
        filtered.push(trimmed)
    end for

    if filtered.Count() = 0
        return "1080p,720p,480p,360p,240p,144p"
    end if

    return filtered.Join(",")
end function

function LogAvailableVideoSources(metadata as object) as void
    adaptiveFormats = ValidArray(metadata.adaptiveFormats)
    formatStreams = ValidArray(metadata.formatStreams)

    lines = []
    AddVideoSourceLines(lines, adaptiveFormats, "adaptive")
    AddVideoSourceLines(lines, formatStreams, "muxed")

    if lines.Count() = 0
        LogDebug("Available video sources: none")
        return
    end if

    LogDebug("Available video sources:\n" + lines.Join(`\n`))
end function

function AddVideoSourceLines(lines as object, formats as object, sourceLabel as string) as void
    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        lines.Push(FormatVideoSourceLine(fmt, sourceLabel))
    end for
end function

function FormatVideoSourceLine(fmt as object, sourceLabel as string) as string
    itag = ValidString(fmt["itag"])
    mimeType = ValidString(fmt["type"])
    parsed = ParseMimeType(mimeType)
    container = parsed.container
    codec = parsed.codec

    resolution = ValidString(fmt["resolution"])
    if StringUtils.IsNullOrEmpty(resolution)
        resolution = ValidString(fmt["qualityLabel"])
    end if
    if StringUtils.IsNullOrEmpty(resolution)
        resolution = ValidString(fmt["size"])
    end if

    fps = ValidString(fmt["fps"])
    bitrate = FormatBitrate(fmt["bitrate"])

    parts = [sourceLabel]
    if not StringUtils.IsNullOrEmpty(itag)
        parts.Push(`itag=${itag}`)
    end if
    if not StringUtils.IsNullOrEmpty(container)
        parts.Push(`container=${container}`)
    end if
    if not StringUtils.IsNullOrEmpty(codec)
        parts.Push(`codec=${codec}`)
    end if
    if not StringUtils.IsNullOrEmpty(resolution)
        parts.Push(`res=${resolution}`)
    end if
    if not StringUtils.IsNullOrEmpty(fps)
        parts.Push(`fps=${fps}`)
    end if
    if not StringUtils.IsNullOrEmpty(bitrate)
        parts.Push(`bitrate=${bitrate}`)
    end if
    if fmt["drmFamilies"] <> invalid
        parts.Push(`drm=${ToString(fmt["drmFamilies"])}`)
    end if

    return parts.Join(" ")
end function

function LogDeviceVideoCapabilities(metadata as object) as void
    deviceInfo = CreateObject("roDeviceInfo")
    if deviceInfo = invalid
        LogDebug("Device video decode capabilities: roDeviceInfo unavailable")
        return
    end if

    combos = {}
    AppendVideoDecodeCombos(combos, ValidArray(metadata.adaptiveFormats), "dash")
    AppendVideoDecodeCombos(combos, ValidArray(metadata.formatStreams), "")

    if combos.Count() = 0
        LogDebug("Device video decode capabilities: no codecs to check")
        return
    end if

    lines = []
    for each key in combos
        combo = combos[key]
        result = deviceInfo.CanDecodeVideo({ codec: combo.codec, container: combo.container })
        lines.Push(`${combo.container}/${combo.codec}=${FormatDecodeInfo(result)}`)
    end for

    LogDebug("Device video decode capabilities:\n" + lines.Join(`\n`))
end function

function AppendVideoDecodeCombos(combos as object, formats as object, containerOverride as string) as void
    for each fmt in formats
        mimeType = ValidString(fmt["type"])
        if StringUtils.IsNullOrEmpty(mimeType) or not mimeType.StartsWith("video/")
            continue for
        end if

        parsed = ParseMimeType(mimeType)
        codec = NormalizeVideoCodec(parsed.codec)
        if StringUtils.IsNullOrEmpty(codec)
            continue for
        end if

        container = containerOverride
        if StringUtils.IsNullOrEmpty(container)
            container = parsed.container
        end if
        if StringUtils.IsNullOrEmpty(container)
            continue for
        end if

        key = `${container}|${codec}`
        if not combos.DoesExist(key)
            combos[key] = { container: container, codec: codec }
        end if
    end for
end function

function ParseMimeType(mimeType as string) as object
    result = { container: "", codec: "" }
    if StringUtils.IsNullOrEmpty(mimeType)
        return result
    end if

    parts = mimeType.Split(";")
    typePart = parts[0].Trim()
    slashIndex = typePart.InStr("/")
    if slashIndex <> -1
        result.container = typePart.Mid(slashIndex + 1)
    end if

    for each part in parts
        trimmed = part.Trim()
        if trimmed.StartsWith("codecs=")
            codecList = trimmed.Mid(7)
            codecList = codecList.Replace(chr(34), "")
            codecList = codecList.Replace("'", "")
            result.codec = codecList
            exit for
        end if
    end for

    return result
end function

function NormalizeVideoCodec(codecList as string) as string
    if StringUtils.IsNullOrEmpty(codecList)
        return ""
    end if

    codec = codecList.Split(",")[0].Trim()
    lower = LCase(codec)
    if lower.StartsWith("av01")
        return "av1"
    else if lower.StartsWith("avc1") or lower.StartsWith("avc3")
        return "h264"
    else if lower.StartsWith("hev1") or lower.StartsWith("hvc1")
        return "h265"
    else if lower.StartsWith("vp9")
        return "vp9"
    else if lower.StartsWith("vp8")
        return "vp8"
    end if

    return ""
end function

function FormatBitrate(value as dynamic) as string
    bitrate = ValidInt(value)
    if bitrate <= 0
        return ""
    end if
    kbps = bitrate \ 1000
    if kbps <= 0
        return `${bitrate} bps`
    end if
    return `${kbps} kbps`
end function

function FormatDecodeInfo(value as dynamic) as string
    if IsBool(value)
        return value.ToStr()
    end if
    if IsAssociativeArray(value) and value.DoesExist("result")
        return ToString(value["result"])
    end if
    return ToString(value)
end function

function BuildMuxerUrl(preferences as object, metadata as object, preferredQuality as dynamic) as dynamic
    muxerBaseUrl = ValidString(preferences["playback.muxer_base_url"])
    muxerBaseUrl = muxerBaseUrl.Trim()
    if StringUtils.IsNullOrEmpty(muxerBaseUrl)
        return invalid
    end if

    if not Prefers4kQuality(preferredQuality)
        return invalid
    end if

    muxerBaseUrl = NormalizeMuxerBaseUrl(muxerBaseUrl)
    if StringUtils.IsNullOrEmpty(muxerBaseUrl)
        return invalid
    end if

    if muxerBaseUrl.Len() >= 5 and muxerBaseUrl.Right(5) = "/dash"
        muxerUrl = muxerBaseUrl
    else if muxerBaseUrl.Len() >= 4 and muxerBaseUrl.Right(4) = "/mux"
        muxerUrl = muxerBaseUrl
    else
        muxerUrl = StringUtils.PathJoin(muxerBaseUrl, "mux")
    end if

    videoId = metadata.videoId
    if StringUtils.IsNullOrEmpty(videoId)
        return invalid
    end if

    return UrlUtils.AppendQueryParams(muxerUrl, {
        v: videoId
        quality: "2160p"
        container: "webm"
    })
end function

function NormalizeMuxerBaseUrl(url as string) as string
    normalized = url.Trim()
    if StringUtils.IsNullOrEmpty(normalized)
        return ""
    end if

    lower = LCase(normalized)
    if lower.StartsWith("http//")
        normalized = "http://" + normalized.Mid(6)
        lower = LCase(normalized)
    else if lower.StartsWith("https//")
        normalized = "https://" + normalized.Mid(7)
        lower = LCase(normalized)
    end if

    if not lower.StartsWith("http://") and not lower.StartsWith("https://")
        normalized = "http://" + normalized
    end if

    if normalized.EndsWith("/")
        normalized = normalized.Left(normalized.Len() - 1)
    end if

    return normalized
end function

function Prefers4kQuality(preferredQuality as dynamic) as boolean
    if not IsString(preferredQuality)
        return false
    end if

    values = preferredQuality.split(",")
    for each value in values
        candidate = LCase(value.Trim())
        if candidate = "2160p" or candidate = "2160" or candidate = "4k"
            return true
        end if
    end for

    return false
end function

function DeviceSupportsAv1Dash() as boolean
    deviceInfo = CreateObject("roDeviceInfo")
    if deviceInfo = invalid
        return false
    end if

    decodeInfo = deviceInfo.CanDecodeVideo({ "codec": "av1", "container": "dash" })
    if IsBool(decodeInfo)
        return decodeInfo
    end if

    if IsAssociativeArray(decodeInfo)
        return ValidBool(decodeInfo.result)
    end if

    return false
end function

function SupportsHls(metadata as object) as boolean
    return not StringUtils.IsNullOrEmpty(metadata.hlsUrl)
end function

function SupportsDash(metadata as object) as boolean
    if not IsArray(metadata.adaptiveFormats) or metadata.adaptiveFormats.Count() = 0
        return false
    end if

    for each fmt in metadata.adaptiveFormats
        if not StringUtils.IsNullOrEmpty(fmt.url)
            return true
        end if
    end for

    return false
end function

function SupportsMuxedFormats(metadata as object) as boolean
    return IsArray(metadata.formatStreams) and metadata.formatStreams.Count() > 0
end function

function SupportsDrmDashManifestUrl(metadata as object) as boolean
    if StringUtils.IsNullOrEmpty(metadata.drmParams)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.dashUrl)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.drmSessionId)
        return false
    end if

    if StringUtils.IsNullOrEmpty(metadata.cpn)
        return false
    end if

    if not IsArray(metadata.licenseInfos) or metadata.licenseInfos.Count() = 0
        return false
    end if

    return true
end function

function AddHlsUrls(streamUrls as object, metadata as object, preferredQuality as string, backend as string, proxyVideos as string, playletServerPort as integer)
    hlsUrl = metadata.hlsUrl
    hlsUrlLocal = invalid
    hlsUrlFiltered = invalid
    hlsUrlFilteredLocal = invalid

    supportsProxying = backend <> "playlet"
    hasQuality = not StringUtils.IsNullOrEmpty(preferredQuality) and preferredQuality <> "auto"

    if supportsProxying
        hlsUrlLocal = UrlUtils.AppendQueryParams(hlsUrl, { local: "true" })
    end if

    ' Redirect to Playet's local web server, where we will be
    ' dynamically adding storyboards to the HLS manifest, and filter quality
    hlsUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/hls`, { url: hlsUrl, v: metadata.videoId })
    if supportsProxying
        hlsUrlLocal = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/hls`, { url: hlsUrlLocal, v: metadata.videoId })
    end if

    if hasQuality
        hlsUrlFiltered = UrlUtils.AppendQueryParams(hlsUrl, { quality: preferredQuality })
        if supportsProxying
            hlsUrlFilteredLocal = UrlUtils.AppendQueryParams(hlsUrlLocal, { quality: preferredQuality })
        end if
    end if

    AddUrls(streamUrls, hlsUrl, hlsUrlLocal, hlsUrlFiltered, hlsUrlFilteredLocal, proxyVideos)
end function

function AddDashUrls(streamUrls as object, metadata as object, preferredQuality as string, backend as string, proxyVideos as string, playletServerPort as integer) as void
    ' Redirect to Playet's local web server, where will will be
    ' dynamically generating the DASH manifest, and filter quality
    dashUrl = UrlUtils.AppendQueryParams(`http://127.0.0.1:${playletServerPort}/api/dash`, {
        v: metadata.videoId
    })

    dashUrlLocal = invalid
    dashUrlFiltered = invalid
    dashUrlFilteredLocal = invalid

    supportsProxying = backend <> "playlet"
    hasQuality = not StringUtils.IsNullOrEmpty(preferredQuality) and preferredQuality <> "auto"

    if supportsProxying
        dashUrlLocal = UrlUtils.AppendQueryParams(dashUrl, { local: "true" })
    end if

    if hasQuality
        dashUrlFiltered = UrlUtils.AppendQueryParams(dashUrl, { quality: preferredQuality })
        if supportsProxying
            dashUrlFilteredLocal = UrlUtils.AppendQueryParams(dashUrlLocal, { quality: preferredQuality })
        end if
    end if

    AddUrls(streamUrls, dashUrl, dashUrlLocal, dashUrlFiltered, dashUrlFilteredLocal, proxyVideos)
end function

function AddUrls(streamUrls as object, url as string, urlLocal as dynamic, urlFiltered as dynamic, urlFilteredLocal as dynamic, proxyVideos as string)
    if proxyVideos = "if_needed"
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    else if proxyVideos = "never"
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
    else if proxyVideos = "always"
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    end if

    if streamUrls.Count() = 0
        if urlFiltered <> invalid
            streamUrls.push(urlFiltered)
        end if
        streamUrls.push(url)
        if urlFilteredLocal <> invalid
            streamUrls.push(urlFilteredLocal)
        end if
        if urlLocal <> invalid
            streamUrls.push(urlLocal)
        end if
    end if
end function

function AddInstanceToUrlIfNeeded(url as dynamic, instance as string) as dynamic
    if IsString(url) and url.StartsWith("/")
        return instance + url
    end if
    return url
end function

function SetCaptions(metadata as object, service as object, contentNode as object) as void
    if metadata.captions.Count() = 0
        return
    end if

    isoLanguageList = StringUtils.ParseJsonSafe(ReadAsciiFile("libpkg:/config/ISO-639-1-to-ISO-639-2T.json5"))
    instance = service.GetInstance()

    subtitleTracks = []

    for each caption in metadata.captions
        code = caption.language_code
        if StringUtils.IsNullOrEmpty(code)
            continue for
        end if

        if code.InStr("-") <> -1
            code = code.Split("-")[0]
        end if

        if code.len() = 2
            if not isoLanguageList.DoesExist(code)
                continue for
            end if
            code = isoLanguageList[code]
        end if

        url = caption.url
        if not url.StartsWith("http")
            url = instance + url
        end if

        subtitleTracks.Push({
            Description: caption.label
            Language: code
            TrackName: url
        })
    end for

    contentNode.ClosedCaptions = True
    contentNode.SubtitleTracks = subtitleTracks
end function
